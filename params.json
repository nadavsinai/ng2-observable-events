{
  "name": "Ng2-observable-events",
  "tagline": "A little helper to get observable of any dom event on any node in component",
  "body": "# Observable Events Directive\r\n\r\nAngular 2 pushes the developer towards observable \"stream\" programming. \r\nThis is modeled very nicely for state changes using inputs and the async pipe.\r\nHowever getting dom events observables is a bit cumbersome if done right,I made this little helper to make it a little easier.\r\n\r\nIt is easy to use [Rx.Observable.fromEvent](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent) constructor somewhere in your component code, \r\nhowever this will be against angular 2 paradigm of not accessing the DOM directly as for the first paramter you will need reference to a native DOM element.\r\n\r\nMy code uses [Rx.Observable.fromEventPattern](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEventPattern), utilizing the renderer .listen method\r\n which goes though all the abstraction needed for both the webWorker and server use cases as well as the obvious browser use case.\r\n \r\n \r\n##Use\r\n\r\n- Add the exported ObservableEvents directive class to your directives array in your component or below it.\r\n- use the ObsEvents='' attribute selector on the dom element you would like to monitor, the value should be the event type (without the \"on\") eg : ObsEvents=\"click\"\r\n- If you need more than one event observable you can separate multiple event names with a comma eg : ObsEvents=\"mousemove,mouseup,mousedown\" \r\n- add a local template variable to the DOM node - #myObs='$' , the part that's set here is the $ in the value's place, myObs is just an example\r\n- use @ViewChild('myObs') to recieve the exported observable to your component's class, remember it is only available after ngAfterViewInit hook has been called.\r\n\r\nexample code in src folder\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}